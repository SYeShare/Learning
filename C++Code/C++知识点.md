### 结构体和类的区别

> + 对于结构中的实例字段成员，不能在声明时赋值初始化
> + 声明了结构类型后，可以使用new运算符创建构造对象，也可以不用new。若不用new，那在初始化所有字段之前，字段将保持未赋值状态且对象不可用  
> + **结构在堆栈中创建，是值类型，而类是引用类型** 

#### 	值类型和引用类型的区别

> + byte，short，int，long，float，double，decimal，char，bool 和 struct 统称为值类型。值类型变量声明后，不管是否已经赋值，编译器为其分配内存
>
> + string 和 class统称为引用类型。当声明一个类时，只在栈中分配一小片内存用于容纳一个地址，而此时**并没有为其分配堆上的内存空间**。当使用 new 创建一个类的实例时，分配堆上的空间，并把堆上空间的地址保存到栈上分配的小片空间中
>
>   > 注：new 的位置可以堆可以栈?如何查看具体的位置呢？ --- linux
>   >
>   > '在linux目录下：cat /proc/pid/maps查看'
>   >
>   > ![alt ](..\Code\9_image\0327New保存的位置栈.png)
>   >
>   > 
>   >
>   > ![alt](..\Code\9_image\New保存的位置.png)
>   >
>   > ```最后一项是映射的文件名。对匿名映射来说，是此段虚拟内存在进程中的角色。[stack]表示在进程中作为栈使用，[heap]表示堆。其余情况则无显示```  第一个示例可以确认的是new的数据此时并不在堆数据区中/ then……





#### 结构体与类的构造函数--包含&继承

**示例：-（S=Struct   C=Class  Con=Conntain  Inher=Inherit）**

![alt 构造函数](..\Code\9_image\运行结果.png  "示例：s表示struct/c表示class")



#### 构造函数相关---调用构造函数的顺序

##### 初始化列表 & 默认构造函数 & 静态构造函数  & 拷贝构造函数

需使用初始化列表的条件：

> + 数据成员是对象，并且这个对象**只有含参数的构造函数**，没有无参数的构造函数
>
> + 对象引用或者cosnt修饰的数据成员
>
> + 子类初始化父类的私有成员，需要在(并且也只能在)参数初始化列表中显示调用父类的构造函数
>
>   > ![初始化列表三](..\Code\9_image\初始化列表三.png "不能在构造函数内部被显示调用.  否则Test对象的生命周期只在{}内")
>   >
>   > ![初始化列表三_比较](..\Code\9_image\初始化列表三_比较.png)

##### 包含关系中，初始化列表与构造函数的调用顺序





> 

> 





### 内联函数的优缺点

> 优：较于普通函数 效率更高；体现在调用方式上：编译时直接拷贝到调用处，类似宏
>
> 劣：增加代码的大小(可执行文件)







***软件：Typora  &&  TranslucentTB***



****

### sscanf 切割字符串，可用正则表达式

> 规则：  以空格为默认分隔符
>
> ​		%*\[^, ]   跳过, 这些匹配项
> ​		%\[^,]		匹配逗号

***

#### c++  待了解的用法
树📕 深度遍历 / 广度遍历 
智能指针 *p

BOOL32 CMtMgrInst::Poweron( const CMessage * pcMsg )
{
	CMgrCBObj *pObj = new CMediaPortCBDistrib<CMtMgrInst>(this, &CMtMgrInst::CBEntry, GetAppID(), GetInsID());
}

##### 定时呼叫默认是不强拆  @强拆