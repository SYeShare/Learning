### 结构体和类的区别

> + 对于结构中的实例字段成员，不能在声明时赋值初始化
> + 声明了结构类型后，可以使用new运算符创建构造对象，也可以不用new。若不用new，那在初始化所有字段之前，字段将保持未赋值状态且对象不可用  
> + **结构在堆栈中创建，是值类型，而类是引用类型** 

#### 	值类型和引用类型的区别

> + byte，short，int，long，float，double，decimal，char，bool 和 struct 统称为值类型。值类型变量声明后，不管是否已经赋值，编译器为其分配内存
> + string 和 class统称为引用类型。当声明一个类时，只在栈中分配一小片内存用于容纳一个地址，而此时**并没有为其分配堆上的内存空间**。当使用 new 创建一个类的实例时，分配堆上的空间，并把堆上空间的地址保存到栈上分配的小片空间中

#### 结构体与类的构造函数

**示例：-（S=Struct   C=Class  Con=Conntain  Inher=Inherit）**

![alt 构造函数](E:\18Git\Code\9_image\运行结果.png  "示例：s表示struct/c表示class")









`最近才知道struct和class的静态构造函数的触发规则是不同的，不像class在第一次使用类的时候触发静态构造函数。如果只访问struct实例的字段是不会触发静态构造函数调用的。通过测试发现当访问静态字段，struct本身的函数（静态和实例）和带参数的构造函数就会引起静态构造函数的执行。而调用默认构造和未覆写的基类虚函数是不会的。为什么呢？
   让我们先来看看class和struct在调用构造函数时的区别。class使用newobj指令而struct使用initobj指令来构造对象。newobj在堆上申请一块内存并调用相应的构造函数进行初始化，然后将对象地址返回给计算栈。initobj则是从本地变量表中载入已经分配出来的struct实例然后初始化struct的各字段。这个初始化过程是CLR内部执行的，而不像class编译器会给class添加一个默认构造函数（这就是为什么struct不能给字段添加默认值的原因。但在类中如果给字段添加了默认值编译器就会自动在构造函数中添加字段赋值操作）。如果给struct中定义了一个有参数的构造函数，那么系统就不会使用initobj指令，而是直接用call指令调用带参数的构造函数。`

#### 构造函数相关

##### 初始化列表 & 默认构造函数 & 静态构造函数  & 拷贝构造函数

> 初始化列表在编译时初始化，构造在运行时初始化   **? 待确认**
>
> > + 数据成员是对象，并且这个对象**只有含参数的构造函数**，没有无参数的构造函数
> >
> > + 对象引用或者cosnt修饰的数据成员
> > + 子类初始化父类的私有成员，需要在(并且也只能在)参数初始化列表中显示调用父类的构造函数

> 

> 

> 

### 内联函数的优缺点

> 优：较于普通函数 效率更高；体现在调用方式上：编译时直接拷贝到调用处，类似宏
>
> 劣：增加代码的大小(可执行文件)







***软件：Typora  &&  TranslucentTB***



****

### sscanf 切割字符串，可用正则表达式

> 规则：  以空格为默认分隔符
>
> ​		%*\[^, ]   跳过, 这些匹配项
> ​		%\[^,]		匹配逗号

***

#### c++  待了解的用法
树📕 深度遍历 / 广度遍历 
智能指针 *p

BOOL32 CMtMgrInst::Poweron( const CMessage * pcMsg )
{
	CMgrCBObj *pObj = new CMediaPortCBDistrib<CMtMgrInst>(this, &CMtMgrInst::CBEntry, GetAppID(), GetInsID());
}

##### 定时呼叫默认是不强拆  @强拆